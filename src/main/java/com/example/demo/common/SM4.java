package com.example.demo.common;

import com.tencent.crypto.provider.SMCSProvider;
import lombok.extern.log4j.Log4j2;
import org.springframework.util.StringUtils;
import java.nio.charset.StandardCharsets;
import java.security.SecureRandom;
import java.security.Security;
import java.util.Base64;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

@Log4j2
public class SM4 {

    // Don't change this, otherwise may break with old data
    private static final String ENC_PREFIX = "SM4_IV";
    // Must be same with encryptPassword
    private static final Pattern ENC_REGEX = Pattern.compile("^" + ENC_PREFIX + "\\((.*)\\)$");
    private static final String SM4_ALGORITHM = "SM4";

    // Can be generated by `openssl rand -base64 16`
    // 32 means 32*8=256 bits key.
    private static final String sshSecretKey = "123456";

    static {
        System.out.println("####################");
        //Security.addProvider(new SMCSProvider());
    }

    public static String cbcEncrypt(String password) {
        if (StringUtils.isEmpty(password)) {
            return password;
        }
        try {
            password = SM4.cbcEncrypt(password, sshSecretKey);
        } catch (Exception e) {
            log.error("[TSF Common] Encrypt failed;", e);
        }
        return password;
    }

    public static String cbcDecrypt(String password) {
        if (StringUtils.isEmpty(password)) {
            return password;
        }
        try {
            password = SM4.cbcDecrypt(password, sshSecretKey);
        } catch (Exception e) {
            log.error("[TSF Common] Decrypt failed;", e);
        }
        return password;
    }

    public static String cbcEncrypt(String password, String secretKey) throws Exception {

        SecretKey sk = new SecretKeySpec(base64Decode(secretKey), SM4_ALGORITHM);
        byte[] iv = iv();
        IvParameterSpec paramSpec = new IvParameterSpec(iv);
        // mode 不能修改，否则会引起兼容性问题
        Cipher cipher = Cipher.getInstance("SM4/CBC/PKCS7Padding", "SMCSProvider");
        cipher.init(Cipher.ENCRYPT_MODE, sk, paramSpec);
        byte[] ciphertext = cipher.doFinal(password.getBytes(StandardCharsets.UTF_8));

        String pass = base64Encode(iv) + ";" + base64Encode(ciphertext);
        return String.format(ENC_PREFIX + "(%s)", pass);
    }

    public static String cbcDecrypt(String password, String secretKey) throws Exception {
        // Not match, return the plain password
        Matcher matcher = ENC_REGEX.matcher(String.valueOf(password));
        if (!matcher.matches()) {
            return password;
        }

        String ivAndPassword = matcher.group(1);
        String[] parts = ivAndPassword.split(";");
        if (parts.length != 2) {
            throw new RuntimeException("encrypted password invalid");
        }

        IvParameterSpec paramSpec = new IvParameterSpec(base64Decode(parts[0]));
        SecretKey sk = new SecretKeySpec(base64Decode(secretKey), SM4_ALGORITHM);
        // mode 不能修改，否则会引起兼容性问题
        Cipher cipher = Cipher.getInstance("SM4/CBC/PKCS7Padding", "SMCSProvider");
        cipher.init(Cipher.DECRYPT_MODE, sk, paramSpec);
        byte[] cleartext = cipher.doFinal(base64Decode(parts[1]));

        return new String(cleartext, StandardCharsets.UTF_8);
    }

    private static byte[] base64Decode(String src) throws Exception {
        return Base64.getDecoder().decode(src.getBytes(StandardCharsets.UTF_8));
    }

    private static String base64Encode(byte[] src) throws Exception {
        return new String(Base64.getEncoder().encode(src), StandardCharsets.UTF_8);
    }

    public static byte[] iv() throws Exception {
        byte[] iv = new byte[16];
        SecureRandom random = new SecureRandom();
        random.nextBytes(iv);
        return iv;
    }


}
